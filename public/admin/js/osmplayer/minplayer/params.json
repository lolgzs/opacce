{"name":"minPlayer","body":"minPlayer - Because less IS more.\r\n===================================\r\n\r\nThe goal of this project is to provide a slim, well documented, object oriented,\r\nplugin-based \"core\" media player in which other players and libraries can build\r\non top of.  It is written using object oriented JavaScript and is continuously\r\nintegrated using JSLint, JSDoc, and Google Closure.\r\n\r\n\r\n\r\nMultiple players - One single API.\r\n-----------------------------------\r\nIt also allows for hot-swappable 3rd party API players by providing a common\r\nAPI for all of these players so that they can be utilized in the same manner.\r\nThis means that once you develop for the minPlayer, one can easily bring in a\r\ndifferent player an your code will still function as it would for all the\r\nothers.  Out of the box, this player provides a common API for YouTube, Vimeo,\r\nHTML5, and Flash with more on the way.\r\n\r\nEverything is a plugin\r\n-----------------------------------\r\nSince this is a plugin-based media player, every displayable class must derive\r\nfrom the plugin class, thereby, making it a plugin.  This includes the media\r\nplayer itself.  This plugin system is highly flexible to be able to handle\r\njust about any type of plugin imaginable, and allows for every plugin to have\r\ndirect dependeny-injected control over any other plugin within the media player.\r\n\r\nComplete User Interface & Business Logic separation\r\n-----------------------------------\r\nOne common complaint for many media solutions out there is that they hijack the\r\nDOM and build out their own controls to provide consistency amongst different\r\nbrowsers.  They do this, however, within the core player which completely binds\r\nthe user interface to the business logic of the media player.  The minPlayer\r\ntakes a different approach by keeping ALL user interface functionality within\r\nthe \"templates\" directory, where each template essentially derives from the base\r\nBusiness logic classes only to provide the user interface aspects of that control.\r\nThis allows for easy templating of the media player besides just overriding the\r\nCSS like current media solutions do today.\r\n\r\nNo \"Features\"!\r\n-----------------------------------\r\nI am pleased to say that this media player does NOT have many features, and this\r\nis on purpose.  Since this is a \"core\" player, it does not have any features\r\nother than what is critical in presenting your media.  Any additional \"bling\"\r\nwill be added to this player from different repositories and from different\r\nplayers that extend this \"core\" functionality.  This methodology will keep this\r\n\"core\" media solution lean & highly functional.\r\n\r\nAPI\r\n-----------------------------------\r\nThe API for minPlayer is very simple.  It revolves around a single API that is\r\nable to retrieve any plugin even before that plugin is created.  By doing this,\r\nyou can have complete control over any plugin within the minPlayer.  This API\r\nis simply called\r\n\r\n```\r\nminplayer.get();\r\n```\r\n\r\nThis API can take up to three different argument with each argument providing\r\ndifferent usage.  The code docs for this function are as follows...\r\n\r\n```\r\n/**\r\n * The main API for minPlayer.\r\n *\r\n * Provided that this function takes three parameters, there are 8 different\r\n * ways to use this api.\r\n *\r\n *   id (0x100) - You want a specific player.\r\n *   plugin (0x010) - You want a specific plugin.\r\n *   callback (0x001) - You only want it when it is ready.\r\n *\r\n *   000 - You want all plugins from all players, ready or not.\r\n *\r\n *          var instances = minplayer.get();\r\n *\r\n *   001 - You want all plugins from all players, but only when ready.\r\n *\r\n *          minplayer.get(function(plugin) {\r\n *            // Code goes here.\r\n *          });\r\n *\r\n *   010 - You want a specific plugin from all players, ready or not...\r\n *\r\n *          var medias = minplayer.get(null, 'media');\r\n *\r\n *   011 - You want a specific plugin from all players, but only when ready.\r\n *\r\n *          minplayer.get('player', function(player) {\r\n *            // Code goes here.\r\n *          });\r\n *\r\n *   100 - You want all plugins from a specific player, ready or not.\r\n *\r\n *          var plugins = minplayer.get('player_id');\r\n *\r\n *   101 - You want all plugins from a specific player, but only when ready.\r\n *\r\n *          minplayer.get('player_id', null, function(plugin) {\r\n *            // Code goes here.\r\n *          });\r\n *\r\n *   110 - You want a specific plugin from a specific player, ready or not.\r\n *\r\n *          var plugin = minplayer.get('player_id', 'media');\r\n *\r\n *   111 - You want a specific plugin from a specific player, only when ready.\r\n *\r\n *          minplayer.get('player_id', 'media', function(media) {\r\n *            // Code goes here.\r\n *          });\r\n *\r\n * @this The context in which this function was called.\r\n * @param {string} id The ID of the widget to get the plugins from.\r\n * @param {string} plugin The name of the plugin.\r\n * @param {function} callback Called when the plugin is ready.\r\n * @return {object} The plugin object if it is immediately available.\r\n */\r\nminplayer.get = function(id, plugin, callback) {\r\n};\r\n```\r\n\r\nThanks and enjoy minPlayer.","tagline":"A minimalistic, plugin-based \"core\" media player for the web.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}